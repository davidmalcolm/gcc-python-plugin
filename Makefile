#   Copyright 2011, 2012 David Malcolm <dmalcolm@redhat.com>
#   Copyright 2011, 2012 Red Hat, Inc.
#
#   This is free software: you can redistribute it and/or modify it
#   under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see
#   <http://www.gnu.org/licenses/>.

GCC=gcc

PLUGIN_SOURCE_FILES= \
  gcc-python.c \
  gcc-python-attribute.c \
  gcc-python-callbacks.c \
  gcc-python-callgraph.c \
  gcc-python-cfg.c \
  gcc-python-closure.c \
  gcc-python-diagnostics.c \
  gcc-python-function.c \
  gcc-python-gimple.c \
  gcc-python-location.c \
  gcc-python-option.c \
  gcc-python-parameter.c \
  gcc-python-pass.c \
  gcc-python-pretty-printer.c \
  gcc-python-rtl.c \
  gcc-python-tree.c \
  gcc-python-variable.c \
  gcc-python-version.c \
  gcc-python-wrapper.c \
  autogenerated-callgraph.c \
  autogenerated-cfg.c \
  autogenerated-option.c \
  autogenerated-function.c \
  autogenerated-gimple.c \
  autogenerated-location.c \
  autogenerated-parameter.c \
  autogenerated-pass.c \
  autogenerated-pretty-printer.c \
  autogenerated-rtl.c \
  autogenerated-tree.c \
  autogenerated-variable.c

PLUGIN_OBJECT_FILES= $(patsubst %.c,%.o,$(PLUGIN_SOURCE_FILES))
GCCPLUGINS_DIR:= $(shell $(GCC) --print-file-name=plugin)

GENERATOR_DEPS=cpybuilder.py wrapperbuilder.py

# The plugin supports both Python 2 and Python 3
#
# In theory we could have arbitrary combinations of python versions for each
# of:
#   - python version used when running scripts during the build (e.g. to
#     generate code)
#   - python version we compile and link the plugin against
#   - when running the plugin with the cpychecker script, the python version
#     that the code is being compiled against
#
# However, to keep things simple, let's assume for now that all of these are
# the same version: we're building the plugin using the same version of Python
# as we're linking against, and that the cpychecker will be testing that same
# version of Python
#
# By default, build against "python", using "python-config" to query for
# compilation options.  You can override this by passing other values for
# PYTHON and PYTHON_CONFIG when invoking "make" (or by simply hacking up this
# file): e.g.
#    make  PYTHON=python3  PYTHON_CONFIG=python3-config  all

# The python interpreter to use:
PYTHON=python
# The python-config executable to use:
PYTHON_CONFIG=python-config

#PYTHON=python3
#PYTHON_CONFIG=python3-config

#PYTHON=python-debug
#PYTHON_CONFIG=python-debug-config

#PYTHON=python3-debug
#PYTHON_CONFIG=python3.2dmu-config

PYTHON_CFLAGS=$(shell $(PYTHON_CONFIG) --cflags)
PYTHON_LDFLAGS=$(shell $(PYTHON_CONFIG) --ldflags)

CFLAGS+= -I$(GCCPLUGINS_DIR)/include -fPIC -fno-strict-aliasing -O2 -Wall -Werror -g $(PYTHON_CFLAGS) $(PYTHON_LDFLAGS)
ifneq "$(PLUGIN_PYTHONPATH)" ""
  CFLAGS+= -DPLUGIN_PYTHONPATH='"$(PLUGIN_PYTHONPATH)"'
endif

all: autogenerated-config.h testcpybuilder test-suite testcpychecker

plugin: autogenerated-config.h python.so

python.so: $(PLUGIN_OBJECT_FILES)
	$(GCC) $(CFLAGS) -shared $^ -o $@

clean:
	rm -f *.so *.o
	rm -f autogenerated*
	rm -rf docs/_build

autogenerated-config.h: configbuilder.py generate-config-h.py
	$(PYTHON) generate-config-h.py -o $@ --gcc=$(GCC)

autogenerated-gimple-types.txt: gimple-types.txt.in
	cpp $(CFLAGS) $^ -o $@

autogenerated-rtl-types.txt: rtl-types.txt.in
	cpp $(CFLAGS) $^ -o $@

autogenerated-tree-types.txt: tree-types.txt.in
	cpp $(CFLAGS) $^ -o $@

autogenerated-callgraph.c: $(GENERATOR_DEPS) generate-callgraph-c.py
	$(PYTHON) generate-callgraph-c.py > $@

autogenerated-cfg.c: $(GENERATOR_DEPS) generate-cfg-c.py
	$(PYTHON) generate-cfg-c.py > $@

autogenerated-function.c: $(GENERATOR_DEPS) generate-function-c.py
	$(PYTHON) generate-function-c.py > $@

autogenerated-gimple.c: $(GENERATOR_DEPS) generate-gimple-c.py autogenerated-gimple-types.txt maketreetypes.py
	$(PYTHON) generate-gimple-c.py > $@

autogenerated-location.c: $(GENERATOR_DEPS) generate-location-c.py
	$(PYTHON) generate-location-c.py > $@

autogenerated-option.c: $(GENERATOR_DEPS) generate-option-c.py
	$(PYTHON) generate-option-c.py > $@

autogenerated-parameter.c: $(GENERATOR_DEPS) generate-parameter-c.py
	$(PYTHON) generate-parameter-c.py > $@

autogenerated-pass.c: $(GENERATOR_DEPS) generate-pass-c.py
	$(PYTHON) generate-pass-c.py > $@

autogenerated-pretty-printer.c: $(GENERATOR_DEPS) generate-pretty-printer-c.py
	$(PYTHON) generate-pretty-printer-c.py > $@

autogenerated-tree.c: $(GENERATOR_DEPS) generate-tree-c.py autogenerated-tree-types.txt maketreetypes.py
	$(PYTHON) generate-tree-c.py > $@

autogenerated-rtl.c: $(GENERATOR_DEPS) generate-rtl-c.py autogenerated-rtl-types.txt maketreetypes.py
	$(PYTHON) generate-rtl-c.py > $@

autogenerated-variable.c: $(GENERATOR_DEPS) generate-variable-c.py autogenerated-gimple-types.txt maketreetypes.py
	$(PYTHON) generate-variable-c.py > $@

# Hint for debugging: add -v to the gcc options 
# to get a command line for invoking individual subprocesses
# Doing so seems to require that paths be absolute, rather than relative
# to this directory
TEST_CFLAGS= \
  -fplugin=$(shell pwd)/python.so \
  -fplugin-arg-python-script=test.py

# A catch-all test for quick experimentation with the API:
test: plugin
	$(GCC) -v $(TEST_CFLAGS) $(shell pwd)/test.c

# Selftest for the cpychecker.py code:
testcpychecker: plugin
	$(PYTHON) testcpychecker.py -v

# Selftest for the cpybuilder code:
testcpybuilder:
	$(PYTHON) testcpybuilder.py -v

dump_gimple:
	$(GCC) -fdump-tree-gimple $(shell pwd)/test.c

debug: plugin
	$(GCC) -v $(TEST_CFLAGS) $(shell pwd)/test.c

# A simple demo, to make it easy to demonstrate the cpychecker:
demo: plugin
	./gcc-with-cpychecker $(shell $(PYTHON_CONFIG) --cflags) demo.c

json-examples: plugin
	./gcc-with-cpychecker -I/usr/include/python2.7 libcpychecker/html/test/example1/bug.c

test-suite: plugin
	$(PYTHON) run-test-suite.py

show-ssa: plugin
	./gcc-with-python examples/show-ssa.py test.c

html: docs/tables-of-passes.rst docs/passes.svg
	cd docs && $(MAKE) html

# We commit this generated file to SCM to allow the docs to be built without
# needing to build the plugin:
docs/tables-of-passes.rst: plugin generate-tables-of-passes-rst.py
	./gcc-with-python generate-tables-of-passes-rst.py test.c > $@

# Likewise for this generated file:
docs/passes.svg: plugin generate-passes-svg.py
	./gcc-with-python generate-passes-svg.py test.c

# Utility target, to help me to make releases
#   - creates a tag in git, and pushes it
#   - creates a tarball
#
# The following assumes that VERSION has been set e.g.
#   $ make tarball VERSION=0.4

tarball:
	-git tag -d v$(VERSION)
	git tag -a v$(VERSION) -m"$(VERSION)"
	git archive --format=tar --prefix=gcc-python-plugin-$(VERSION)/ v$(VERSION) | gzip > gcc-python-plugin-$(VERSION).tar.gz
	sha256sum gcc-python-plugin-$(VERSION).tar.gz
	cp gcc-python-plugin-$(VERSION).tar.gz ~/rpmbuild/SOURCES/

# Notes to self on making a release
# ---------------------------------
#
#  Before tagging:
#
#     * update the version/release in docs/conf.py
#
#     * update the version in gcc-python-plugin.spec
#
#     * add release notes to docs
#
#  Test the candidate tarball via a scratch SRPM build locally (this
#  achieves test coverage against python 2 and 3, for both debug and
#  optimized python, on one arch, against the locally-installed version of
#  gcc):
#
#     $ make srpm VERSION=fixme
#
#     $ make rpm VERSION=fixme
#
#  Test the candidate tarball via a scratch SRPM build in Koji (this
#  achieves test coverage against python 2 and 3, for both debug and
#  optimized python, on both i686 and x86_64, against another version of
#  gcc):
#
#     $ make koji VERSION=fixme
#
#  After successful testing of a candidate tarball:
#
#   * push the tag:
#
#         $ git push --tags
#
#   * upload it to https://fedorahosted.org/releases/g/c/gcc-python-plugin/
#    via:
#
#        $ scp gcc-python-plugin-$(VERSION).tar.gz dmalcolm@fedorahosted.org:gcc-python-plugin
#
#  * add version to Trac: https://fedorahosted.org/gcc-python-plugin/admin/ticket/versions
#
#  * update release info at https://fedorahosted.org/gcc-python-plugin/wiki#Code
#
#  * send release announcement:
#
#      To: gcc@gcc.gnu.org, gcc-python-plugin@lists.fedorahosted.org, python-announce-list@python.org
#      Subject: ANN: gcc-python-plugin $(VERSION)
#      (etc)
#
#  * build it into Fedora

# Utility target, for building test rpms:
srpm:
	rpmbuild -bs gcc-python-plugin.spec

# Perform a test rpm build locally:
rpm:
	rpmbuild -ba gcc-python-plugin.spec

# Perform a test (scratch) build in Koji:
# f16: gcc 4.6
# f17: gcc 4.7
koji: srpm
	koji build --scratch f16 ~/rpmbuild/SRPMS/gcc-python-plugin-$(VERSION)-1.fc15.src.rpm
