/*
   Copyright 2011, 2012 David Malcolm <dmalcolm@redhat.com>
   Copyright 2011, 2012 Red Hat, Inc.

   This is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see
   <http://www.gnu.org/licenses/>.
*/

#include <Python.h>
#include "gcc-python.h"
#include "gcc-python-wrappers.h"
#include "c-common.h" /* for warn_format */
#include "diagnostic.h"


/*
  Wrapper for GCC's opts.h

  opts.h declares:
    extern const struct cl_option cl_options[];
    extern const unsigned int cl_options_count;
  which suggests that this table is fixed in place and thus not resizable.
  (The definition is in the autogenerated DIR/gcc/options.c)

  We specifically wrap:
    enum opt_code
  and use this to get at the associated "struct cl_option" within the
  "cl_options" table.
*/

int
gcc_Option_init(PyGccOption * self, PyObject *args, PyObject *kwargs)
{
    const char *text;
    static char *kwlist[] = {"text", NULL};
    int i;

    /*
      We need to call _track manually as we're not using PyGccWrapper_New():
    */
    gcc_python_wrapper_track(&self->head);

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s", kwlist,
                                      &text)) {
        return -1;
    }

    /* Search for text within cl_options */
    for (i = 0; i < cl_options_count; i++) {
        if (0 == strcmp(cl_options[i].opt_text, text)) {
            self->opt_code = i;
            return 0; /* success */
        }
    }

    /* Not found: */
    PyErr_Format(PyExc_ValueError,
                 "Could not find command line argument with text '%s'",
                 text);
    return -1;
}

PyObject *
gcc_Option_repr(PyGccOption * self)
{
    return gcc_python_string_from_format("gcc.Option('%s')",
                                         gcc_python_option_to_cl_option(self)->opt_text);
}

int gcc_python_option_is_enabled(enum opt_code opt_code)
{
    /* Returns 1 if option OPT_IDX is enabled in OPTS, 0 if it is disabled,
       or -1 if it isn't a simple on-off switch.  */
    int i = option_enabled (opt_code, global_dc->option_state);
    if (i == 1) {
        return 1;
    }
    if (i == 0) {
        return 0;
    }

    /* -1: we don't know */
    /*
      Ugly workaround to allow disabling warnings.

      For many options, it doesn't seem to be possible to disable them
      directly.

      Specifically a cl_option with o.flag_var_offset == -1 will return NULL
      from option_flag_var()

      For these options, option_enabled() will return -1 signifying that "it
      isn't a simple on-off switch".

      diagnostic_report_diagnostic() uses
         if (!option_enabled(...))
            return false
      to suppress disabled warnings.

      However, -1 is true for the purpose of this test.

      For GCC's own uses of the options, they are typically guarded by an
      additional test.  For example, "-Wformat" sets "warn_format", and this
      guards the formatting tests.
     */
    switch (opt_code) {
    default:
        /*  We don't know: */
        return -1;

    case OPT_Wformat:
        return warn_format;
    }
}

PyObject *
gcc_Option_is_enabled(PyGccOption * self, void *closure)
{
    int i = gcc_python_option_is_enabled(self->opt_code);

    if (i == 1) {
        return PyBool_FromLong(1);
    }
    if (i == 0) {
        return PyBool_FromLong(0);
    }

    PyErr_Format(PyExc_NotImplementedError,
                 "The plugin does not know how to determine if gcc.Format('%s') is implemented",
                 gcc_python_option_to_cl_option(self)->opt_text);
    return NULL;
}

const struct cl_option*
gcc_python_option_to_cl_option(PyGccOption * self)
{
    assert(self);
    assert(self->opt_code >= 0);
    assert(self->opt_code < cl_options_count);

    return &cl_options[self->opt_code];
}

PyObject *
gcc_python_make_wrapper_opt_code(enum opt_code opt_code)
{
    struct PyGccOption *opt_obj = NULL;

    opt_obj = PyGccWrapper_New(struct PyGccOption, &gcc_OptionType);
    if (!opt_obj) {
        goto error;
    }

    opt_obj->opt_code = opt_code;

    return (PyObject*)opt_obj;

error:
    return NULL;
}

void
wrtp_mark_for_PyGccOption(PyGccOption *wrapper)
{
    /* empty */
}

/*
  PEP-7
Local variables:
c-basic-offset: 4
indent-tabs-mode: nil
End:
*/
